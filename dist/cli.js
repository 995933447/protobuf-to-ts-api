#!/usr/bin/env node
(()=>{"use strict";var e={n:o=>{var t=o&&o.__esModule?()=>o.default:()=>o;return e.d(t,{a:t}),t},d:(o,t)=>{for(var r in t)e.o(t,r)&&!e.o(o,r)&&Object.defineProperty(o,r,{enumerable:!0,get:t[r]})},o:(e,o)=>Object.prototype.hasOwnProperty.call(e,o)};const o=require("chalk");var t=e.n(o);const r=require("glob");var s=e.n(r);const n=require("minimist");var a=e.n(n);const i=require("express");var c=e.n(i);const l=require("fs");var p=e.n(l);const d=require("path");var u=e.n(d);const m=require("mkdirp");var f=e.n(m);const h=require("protobufjs-cli/pbjs");var $=e.n(h);const g=require("protobufjs-cli/pbts");var b=e.n(g);const w=require("protobufjs");var y=e.n(w);let v=function(e){return e.post="post",e.get="get",e}({});function q(e,o){if(!e||!e.options)return;const t=o.startsWith("(")?o:`(${o})`;return e.options[t]}const k=(e,o)=>{let t=`\nexport class ${e}Service {`;for(const e of o){let o=`I${e.requestType}`,r=`I${e.responseType}`;e.namespace&&(o=`${e.namespace}.${o}`,r=`${e.namespace}.${r}`),t+=`\n\n  ${e.comment?`/** ${e.comment} */`:"/** no comment **/"}\n  static async ${e.methodName}(req: api.${o}): Promise<api.${r}> {\n    return await request.${e.httpMethod}('${e.urlPath}', ${"get"===e.httpMethod?"{ params: req }":"req"})\n  };`}return t+="\n\n};\n",t};class M{}const P=require("typescript-json-schema"),S=require("json-schema-faker");require("ts-morph");const O=require("fs/promises");async function T(e,o,t){const r=await async function(e,o){const{folder:t=""}=o,r=e.replace(".proto",".js"),s=u().resolve(process.cwd(),t,r),n=u().dirname(s);await f()(n);let a=[];return o.includeProtos&&o.includeProtos.length>0&&(a=o.includeProtos.reduce((e,o)=>e.concat(["-p",u().resolve(process.cwd(),o)]),[])),a.push("-p",o.root,"--keep-case","-t","static-module","-w",o.importModuleStyle,"-o",s,u().resolve(process.cwd(),e)),console.log("pbjs cmd:",a.join(" ")),new Promise((e,o)=>{$().main(a,t=>{t&&o(t),e(s)})})}(e,t),s=await function(e,o){const{folder:t=""}=o,r=u().resolve(process.cwd(),t,e.replace(".js",".d.ts")),s=["-p",o.root,"-o",r,e];return console.log("pbts cmd:",s.join(" ")),new Promise((e,o)=>{b().main(s,t=>{t&&o(t),e(r)})})}(r,t),n=await async function(e,o,t){const{requestModule:r,baseUrl:s}=t,n=u().dirname(o),a=u().basename(o);let i="";i+=((e,o)=>`/* eslint-disable */\nimport request from "${e}";\nimport api from './${o.replace(".ts","")}';\n`)(r,a);const c=await async function(e,o){const t=p().readFileSync(e,"utf8"),r=y().parse(t,{keepCase:!0,preferTrailingComment:!0,alternateCommentMode:!0}).root;r.resolveAll();const s=[],n=function(e,t){for(const r of Object.values(e.nested||{})){if(r instanceof y().Service){console.log(`Service: ${r.name}`);for(const[e,n]of Object.entries(r.methods))if(console.log(`  Method: ${e}`),console.log(`  Method comment: ${n.comment||""}`),o.protoOptionTagHttpMethod||o.protoOptionTagHttpPath){if(n.options){for(const[e,o]of Object.entries(n.options))console.log(`    Option: ${e} = ${JSON.stringify(o)}`);let a=q(n,o.protoOptionTagHttpMethod),i=q(n,o.protoOptionTagHttpPath);if(a||i){a||(a=v.post),i||(i=`/${r.name}/${e}`,t&&(i=`/${t}/${r.name}/${e}`));const c=new M;s.push(c),c.serviceName=r.name,c.methodName=e,c.requestType=n.requestType,c.responseType=n.responseType,c.namespace=t||void 0,c.httpMethod=a.toLowerCase(),c.urlPath=o.baseUrl+i,c.comment=n.comment||""}}}else{const a=new M;s.push(a),a.serviceName=r.name,a.methodName=e,a.requestType=n.requestType,a.responseType=n.responseType,a.namespace=t||void 0,a.httpMethod=v.post;let i=`/${a.serviceName}/${e}`;a.namespace&&(i=`/${a.namespace}/${a.serviceName}/${e}`),a.urlPath=o.baseUrl+i,a.comment=n.comment||""}}if(r instanceof y().Namespace){const e=t?`${t}.${r.name}`:r.name;n(r,e)}}};return n(r,""),s}(e,t),l=new Map;for(const e of c){let o=e.serviceName||"";var d;e.namespace&&(e.namespace.toLowerCase()!=o.toLowerCase()&&(o=e.namespace+o.slice(0,1).toUpperCase()+o.slice(1)),l.get(o)||l.set(o,[]),null===(d=l.get(o))||void 0===d||d.push(e))}for(const[e,o]of l)i+=k(e,o);return await p().promises.writeFile(u().resolve(n,a.replace(".d.ts","_api.ts")),i),c}(e,s,t),a=await async function(e){const o=(0,P.getProgramFromFiles)([u().resolve(e)],{strictNullChecks:!0},process.cwd()),t=(0,P.buildGenerator)(o,{required:!0}),r=((null==t?void 0:t.getUserSymbols())||[]).filter(e=>/I(\S*)Rsp$/.test(e)),s=null==t?void 0:t.getSchemaForSymbols(r),n=e.replace(".d.ts",".json");return await p().promises.writeFile(n,JSON.stringify(s,null,2),{encoding:"utf-8"}),n}(s),i=await async function(e){const o=await p().promises.readFile(e,{encoding:"utf-8"}),t=JSON.parse(o);S.JSONSchemaFaker.option({alwaysFakeOptionals:!0,resolveJsonPath:!0});const r={};for(const e in t.definitions){const o=e.match(/I(\S*)Rsp$/);if(!o)continue;const s=o[1],n={...t.definitions[e],definitions:t.definitions},a=S.JSONSchemaFaker.generate(n);r[s]=a}const s=JSON.stringify(r,null,2),n=e.replace(".json",".mock.json");return p().writeFileSync(n,s,{encoding:"utf-8"}),n}(a);console.log(`success generate ${e} to ${u().resolve(t.folder,e)}.d.ts and ${u().resolve(t.folder,e)}.ts`),t.mock&&o&&(console.log("begin open mock server"),await async function(e,o,t,r){const{baseUrl:s}=r,n=await p().promises.readFile(o,{encoding:"utf-8"}),a=JSON.parse(n);if(e)for(const o of e)if(o.methodName){let e=o.serviceName?o.serviceName.slice(0,1).toUpperCase()+o.serviceName.slice(1):"",r=`I${o.requestType}`,s=`I${o.responseType}`;o.namespace&&(o.namespace.toLowerCase()!=e.toLowerCase()&&(e=`${o.namespace}${e}`),r=`${o.namespace}.${r}`,s=`${o.namespace}.${s}`);const n=o.httpMethod||"post",i=o.methodName||"",c=o.urlPath||"";switch(n.toLowerCase()){case"get":t.get(c,(e,o)=>o.send(a[i]));break;case"post":t.post(c,(e,o)=>o.send(a[i]));break;case"put":t.put(c,(e,o)=>o.send(a[i]));break;case"delete":t.delete(c,(e,o)=>o.send(a[i]));break;case"patch":t.patch(c,(e,o)=>o.send(a[i]));break;case"head":t.head(c,(e,o)=>o.send(a[i]));break;case"options":t.options(c,(e,o)=>o.send(a[i]));break;default:throw new Error(`Unsupported http method: ${n}`)}console.log(`mockServer generate mock route: ${c} success`)}}(n,i,o,t)),await async function(e,o,t){try{let r=await(0,O.readFile)(e,"utf-8");r=r.replace(o,t),await(0,O.writeFile)(e,r,"utf-8"),console.log(`✅ 替换 ${o} -> ${t} 完成: ${e}`)}catch(e){console.error("❌ 替换失败:",e)}}(s,/import Long = require\("long"\);/g,'import * as Long from "long";')}!async function(){try{const e=a()(process.argv.slice(2),{alias:{requestModule:"r",baseUrl:"b",folder:"f",root:"t",optional:"o",mock:"m",port:"p",help:"h",includeProtos:"i",importModuleStyle:"I"},string:["requestModule","baseUrl","folder","root","port"],boolean:["optional","mock"],default:{requestModule:"axios",baseUrl:"",folder:"./api",root:process.cwd(),optional:!0,mock:!1,port:"3000",help:"",importModuleStyle:"es6"}});e.help&&(process.stderr.write(`Help:\n${t().bold.green("--requestModule -r")}: the request module of you want to set, default is ${t().bold.red("'axios'")}, you can set to your custom request method, for example ${t().bold.red("'@/request'")};\n${t().bold.green("--baseUrl -b")}: the base url of you want to set, default is ${t().bold.red("'/'")}, you can set to your api path, for example ${t().bold.red("'/api'")};\n${t().bold.green("--folder -f")}: the folder of you want to save the output files, default is ${t().bold.red("'./api'")};\n${t().bold.green("--root -t")}: the root path set to protobufjs, default is ${t().bold.red("the path of this command run")};\n${t().bold.green("--optional -o")}: is transfrom d.ts optional to false, because of protobuf 3.0 set all filed is optional, default is ${t().bold.red("true")};\n${t().bold.green("--mock -m")}: is open mock server, default is ${t().bold.red("false")};\n${t().bold.green("--port -p")}: mock server port, default is ${t().bold.red("3000")}; \n${t().bold.green("--include -i")}: include proto files list, default is ${t().bold.red("[]")}; \n${t().bold.green("--protoOptionTagHttpMethod")}: tag of proto option indicate http method}; \n${t().bold.green("--protoOptionTagHttpPath")}: tag of proto option indicate http path};`),process.exit(1));const{_:o}=e,r=[];"string"==typeof e.includeProtos?r.push(e.includeProtos):r.push(...e.includeProtos||[]);const n={requestModule:e.requestModule,baseUrl:e.baseUrl,folder:e.folder,root:e.root,optional:e.optional,mock:e.mock,port:e.port,help:e.help,includeProtos:r,protoOptionTagHttpMethod:e.protoOptionTagHttpMethod,protoOptionTagHttpPath:e.protoOptionTagHttpPath,importModuleStyle:e.importModuleStyle};o.length||(process.stderr.write(`Usage: ${t().bold.green("pb2TSApi")} [options] ${t().bold.red("[file1.proto file2.proto ...]")} or ${t().bold.red("[./**/*.proto]")}`),process.exit(1));const i=await s()(o,{ignore:"node_modules/**",windowsPathsNoEscape:!0});let l;i.length||(process.stderr.write(t().bold.red(`there is not files for the flowing paths: \n ${o.join("\n")}`)),process.exit(1)),n.mock&&(l=function(e){const o=c()(),{port:t="3000"}=e;return o.listen(+t,()=>{console.log(`mock server listening on port ${t}`)}),o}(n)),await Promise.all(i.map(e=>T(e,l,n)))}catch(e){console.error(e),process.exit(1)}}()})();
//# sourceMappingURL=cli.js.map