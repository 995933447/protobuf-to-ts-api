#!/usr/bin/env node
(()=>{"use strict";var e={n:o=>{var t=o&&o.__esModule?()=>o.default:()=>o;return e.d(t,{a:t}),t},d:(o,t)=>{for(var s in t)e.o(t,s)&&!e.o(o,s)&&Object.defineProperty(o,s,{enumerable:!0,get:t[s]})},o:(e,o)=>Object.prototype.hasOwnProperty.call(e,o)};const o=require("chalk");var t=e.n(o);const s=require("glob");var r=e.n(s);const n=require("minimist");var a=e.n(n);const i=require("express");var c=e.n(i);const p=require("fs");var l=e.n(p);const d=require("path");var u=e.n(d);const m=require("mkdirp");var f=e.n(m);const h=require("protobufjs-cli/pbjs");var $=e.n(h);const b=require("protobufjs-cli/pbts");var g=e.n(b);const w=require("protobufjs");var v=e.n(w);let y=function(e){return e.post="post",e.get="get",e}({});function q(e,o){if(!e||!e.options)return;const t=o.startsWith("(")?o:`(${o})`;return e.options[t]}const k=(e,o)=>{let t=`\nexport class ${e}Service {`;for(const e of o){let o=`I${e.requestType}`,s=`I${e.responseType}`;e.namespace&&(o=`${e.namespace}.${o}`,s=`${e.namespace}.${s}`),t+=`\n\n  ${e.comment?`/** ${e.comment} */`:"/** no comment **/"}\n  static async ${e.methodName}(req: api.${o}): Promise<api.${s}> {\n    return await request.${e.httpMethod}('${e.urlPath}', ${"get"===e.httpMethod?"{ params: req }":"req"})\n  };`}return t+="\n\n};\n",t};class P{}const O=require("typescript-json-schema"),T=require("json-schema-faker");async function N(e,o,t){const s=await async function(e,o){const{folder:t=""}=o,s=e.replace(".proto",".js"),r=u().resolve(process.cwd(),t,s),n=u().dirname(r);await f()(n);let a=[];return o.includeProtos&&o.includeProtos.length>0&&(a=o.includeProtos.reduce((e,o)=>e.concat(["-p",u().resolve(process.cwd(),o)]),[])),a.push("-p",o.root,"--keep-case","-t","static-module","-w","commonjs","-o",r,u().resolve(process.cwd(),e)),console.log("pbjs cmd:",a.join(" ")),new Promise((e,o)=>{$().main(a,t=>{t&&o(t),e(r)})})}(e,t),r=await function(e,o){const{folder:t=""}=o,s=u().resolve(process.cwd(),t,e.replace(".js",".d.ts")),r=["-p",o.root,"-o",s,e];return console.log("pbts cmd:",r.join(" ")),new Promise((e,o)=>{g().main(r,t=>{t&&o(t),e(s)})})}(s,t);await l().promises.unlink(s);const n=await async function(e,o,t){const{requestModule:s,baseUrl:r}=t,n=u().dirname(o),a=u().basename(o);let i="";i+=((e,o)=>`/* eslint-disable */\nimport request from "${e}";\nimport api from './${o.replace(".ts","")}';\n`)(s,a);const c=await async function(e,o){const t=l().readFileSync(e,"utf8"),s=v().parse(t,{keepCase:!0,preferTrailingComment:!0,alternateCommentMode:!0}).root;s.resolveAll();const r=[],n=function(e,t){for(const s of Object.values(e.nested||{})){if(s instanceof v().Service){console.log(`Service: ${s.name}`);for(const[e,n]of Object.entries(s.methods))if(console.log(`  Method: ${e}`),console.log(`  Method comment: ${n.comment||""}`),o.protoOptionTagHttpMethod||o.protoOptionTagHttpPath){if(n.options){for(const[e,o]of Object.entries(n.options))console.log(`    Option: ${e} = ${JSON.stringify(o)}`);let a=q(n,o.protoOptionTagHttpMethod),i=q(n,o.protoOptionTagHttpPath);if(a||i){a||(a=y.post),i||(i=`/${s.name}/${e}`,t&&(i=`/${t}/${s.name}/${e}`));const c=new P;r.push(c),c.serviceName=s.name,c.methodName=e,c.requestType=n.requestType,c.responseType=n.responseType,c.namespace=t||void 0,c.httpMethod=a.toLowerCase(),c.urlPath=o.baseUrl+i,c.comment=n.comment||""}}}else{const a=new P;r.push(a),a.serviceName=s.name,a.methodName=e,a.requestType=n.requestType,a.responseType=n.responseType,a.namespace=t||void 0,a.httpMethod=y.post;let i=`/${a.serviceName}/${e}`;a.namespace&&(i=`/${a.namespace}/${a.serviceName}/${e}`),console.log(`    Default URL Path: ${i}`),a.urlPath=o.baseUrl+i,a.comment=n.comment||""}}if(s instanceof v().Namespace){const e=t?`${t}.${s.name}`:s.name;n(s,e)}}};return n(s,""),r}(e,t),p=new Map;for(const e of c){let o=e.serviceName||"";var d;e.namespace&&(e.namespace.toLowerCase()!=o.toLowerCase()&&(o=e.namespace+o.slice(0,1).toUpperCase()+o.slice(1)),p.get(o)||p.set(o,[]),null===(d=p.get(o))||void 0===d||d.push(e))}for(const[e,o]of p)i+=k(e,o);return await l().promises.writeFile(u().resolve(n,a.replace(".d.ts",".ts")),i),c}(e,r,t),a=await async function(e){const o=(0,O.getProgramFromFiles)([u().resolve(e)],{strictNullChecks:!0},process.cwd()),t=(0,O.buildGenerator)(o,{required:!0}),s=((null==t?void 0:t.getUserSymbols())||[]).filter(e=>/I(\S*)Rsp$/.test(e)),r=null==t?void 0:t.getSchemaForSymbols(s),n=e.replace(".d.ts",".json");return await l().promises.writeFile(n,JSON.stringify(r,null,2),{encoding:"utf-8"}),n}(r),i=await async function(e){const o=await l().promises.readFile(e,{encoding:"utf-8"}),t=JSON.parse(o);T.JSONSchemaFaker.option({alwaysFakeOptionals:!0,resolveJsonPath:!0});const s={};for(const e in t.definitions){const o=e.match(/I(\S*)Rsp$/);if(!o)continue;const r=o[1],n={...t.definitions[e],definitions:t.definitions},a=T.JSONSchemaFaker.generate(n);s[r]=a}const r=JSON.stringify(s,null,2),n=e.replace(".json",".mock.json");return l().writeFileSync(n,r,{encoding:"utf-8"}),n}(a);console.log(`success generate ${e} to ${u().resolve(t.folder,e)}.d.ts and ${u().resolve(t.folder,e)}.ts`),t.mock&&o&&(console.log("begin open mock server"),await async function(e,o,t,s){const{baseUrl:r}=s,n=await l().promises.readFile(o,{encoding:"utf-8"}),a=JSON.parse(n);if(e)for(const o of e)if(o.methodName){let e=o.serviceName?o.serviceName.slice(0,1).toUpperCase()+o.serviceName.slice(1):"",s=`I${o.requestType}`,r=`I${o.responseType}`;o.namespace&&(o.namespace.toLowerCase()!=e.toLowerCase()&&(e=`${o.namespace}${e}`),s=`${o.namespace}.${s}`,r=`${o.namespace}.${r}`);const n=o.httpMethod||"post",i=o.methodName||"",c=o.urlPath||"";switch(n.toLowerCase()){case"get":t.get(c,(e,o)=>o.send(a[i]));break;case"post":t.post(c,(e,o)=>o.send(a[i]));break;case"put":t.put(c,(e,o)=>o.send(a[i]));break;case"delete":t.delete(c,(e,o)=>o.send(a[i]));break;case"patch":t.patch(c,(e,o)=>o.send(a[i]));break;case"head":t.head(c,(e,o)=>o.send(a[i]));break;case"options":t.options(c,(e,o)=>o.send(a[i]));break;default:throw new Error(`Unsupported http method: ${n}`)}console.log(`mockServer generate mock route: ${c} success`)}}(n,i,o,t))}!async function(){try{const e=a()(process.argv.slice(2),{alias:{requestModule:"r",baseUrl:"b",folder:"f",root:"t",optional:"o",mock:"m",port:"p",help:"h",includeProtos:"i"},string:["requestModule","baseUrl","folder","root","port"],boolean:["optional","mock"],default:{requestModule:"axios",baseUrl:"",folder:"./api",root:process.cwd(),optional:!0,mock:!1,port:"3000",help:""}});e.help&&(process.stderr.write(`Help:\n${t().bold.green("--requestModule -r")}: the request module of you want to set, default is ${t().bold.red("'axios'")}, you can set to your custom request method, for example ${t().bold.red("'@/request'")};\n${t().bold.green("--baseUrl -b")}: the base url of you want to set, default is ${t().bold.red("'/'")}, you can set to your api path, for example ${t().bold.red("'/api'")};\n${t().bold.green("--folder -f")}: the folder of you want to save the output files, default is ${t().bold.red("'./api'")};\n${t().bold.green("--root -t")}: the root path set to protobufjs, default is ${t().bold.red("the path of this command run")};\n${t().bold.green("--optional -o")}: is transfrom d.ts optional to false, because of protobuf 3.0 set all filed is optional, default is ${t().bold.red("true")};\n${t().bold.green("--mock -m")}: is open mock server, default is ${t().bold.red("false")};\n${t().bold.green("--port -p")}: mock server port, default is ${t().bold.red("3000")}; \n${t().bold.green("--include -i")}: include proto files list, default is ${t().bold.red("[]")}; \n${t().bold.green("--protoOptionTagHttpMethod")}: tag of proto option indicate http method}; \n${t().bold.green("--protoOptionTagHttpPath")}: tag of proto option indicate http path};`),process.exit(1));const{_:o}=e,s=[];"string"==typeof e.includeProtos?s.push(e.includeProtos):s.push(...e.includeProtos||[]);const n={requestModule:e.requestModule,baseUrl:e.baseUrl,folder:e.folder,root:e.root,optional:e.optional,mock:e.mock,port:e.port,help:e.help,includeProtos:s,protoOptionTagHttpMethod:e.protoOptionTagHttpMethod,protoOptionTagHttpPath:e.protoOptionTagHttpPath};o.length||(process.stderr.write(`Usage: ${t().bold.green("pb2TSApi")} [options] ${t().bold.red("[file1.proto file2.proto ...]")} or ${t().bold.red("[./**/*.proto]")}`),process.exit(1));const i=await r()(o,{ignore:"node_modules/**",windowsPathsNoEscape:!0});let p;i.length||(process.stderr.write(t().bold.red(`there is not files for the flowing paths: \n ${o.join("\n")}`)),process.exit(1)),n.mock&&(p=function(e){const o=c()(),{port:t="3000"}=e;return o.listen(+t,()=>{console.log(`mock server listening on port ${t}`)}),o}(n)),await Promise.all(i.map(e=>N(e,p,n)))}catch(e){console.error(e),process.exit(1)}}()})();
//# sourceMappingURL=cli.js.map